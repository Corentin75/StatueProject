#pragma kernel CSMain

RWTexture2D<float4> Result;
Texture2D<float4> _MainTex;
Texture2D<float4> _BrushTex;
SamplerState samplerState;

float4 _BrushColor; // La couleur du pinceau (avec alpha)
float2 _HitPosition; // Position du pinceau (UV)
int2 _TextureSize;

[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _TextureSize.x || id.y >= _TextureSize.y)
        return;

    // Convertir les indices en coordonnées UV (0 à 1)
    float2 uv = id.xy / float2(_TextureSize.x, _TextureSize.y);
    uv.y = 1.0f - uv.y; // Inversion de Y pour correspondre à Unity

    // Calcul des UV du pinceau
    float2 brushUV = (uv - _HitPosition) * 2.0f;

    // Vérifier si on est dans la zone du pinceau
    if (brushUV.x < 0.0f || brushUV.x > 1.0f || brushUV.y < 0.0f || brushUV.y > 1.0f)
    {
        Result[id.xy] = _MainTex[id.xy];
        return;
    }

    // Charger la couleur du pixel d'origine
    float4 baseColor = _MainTex[id.xy];

    // Charger la couleur du pinceau
    int2 brushTexCoords = int2(brushUV * float2(_TextureSize));
    float4 brushMask = _BrushTex.Load(int3(brushTexCoords, 0));

    // Appliquer la transparence du pinceau
    float brushAlpha = brushMask.a * _BrushColor.a;

    // Mélanger la couleur du pinceau avec la texture existante en tenant compte de l’alpha
    float4 newColor = lerp(baseColor, _BrushColor, brushAlpha);
    
    Result[id.xy] = newColor;
}
