#pragma kernel CSMain

RWTexture2D<float4> Result;
Texture2D<float4> _MainTex;
Texture2D<float4> _BrushTex; // Texture de pinceau
SamplerState samplerState; // Ajoutez un SamplerState
float4 _BrushColor;
float2 _HitPosition; // Position du pinceau (en UV normalisé)
int2 _TextureSize;

[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _TextureSize.x || id.y >= _TextureSize.y)
        return;

    // Convertir les indices en coordonnées UV (normalisées entre 0 et 1)
    float2 uv = id.xy / float2(_TextureSize.x, _TextureSize.y);

    // Inverser l'axe Y des coordonnées UV pour correspondre à Unity (Y=0 est en bas)
    uv.y = 1.0f - uv.y;

    // Calculer les coordonnées UV relatives à la texture de pinceau
    float2 brushUV = (uv - _HitPosition) * 2.0f; // Ajuster l'échelle des coordonnées UV du pinceau

    // Vérifier si les coordonnées UV du pinceau sont dans la plage [0, 1]
    if (brushUV.x < 0.0f || brushUV.x > 1.0f || brushUV.y < 0.0f || brushUV.y > 1.0f)
    {
        Result[id.xy] = _MainTex[id.xy];
        return;
    }

    // Récupérer la couleur du pixel à la position (uv)
    float4 baseColor = _MainTex[id.xy];

    // Récupérer la couleur du pinceau à la position (brushUV)
    int2 brushTexCoords = int2(brushUV * float2(_TextureSize));
    float4 brushColor = _BrushTex.Load(int3(brushTexCoords, 0));

    // Appliquer la couleur du pinceau seulement si la couleur du pinceau a une alpha > 0
    if (brushColor.a > 0.0f)
    {
        // Mélanger la couleur du pinceau avec la couleur existante
        float4 newColor = lerp(baseColor, _BrushColor, brushColor.a); // Mélanger la couleur existante avec la couleur du pinceau
        Result[id.xy] = newColor;
    }
    else
    {
        // Conserver la couleur d'origine si le pixel est en dehors de la zone du pinceau
        Result[id.xy] = baseColor;
    }
}
